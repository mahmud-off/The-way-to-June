## Methods
- В Go нет классов. Однако вы можете определять методы для типов.
- Метод - это функция со специальным аргументом получателя.
- Получатель отображается в собственном списке аргументов между ключевым словом func и именем метода.
## Methods are functions
- Remember: a method is just a function with a receiver argument.
```
type Vertex struct {
	X, Y float64
}

func Abs(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(Abs(v))
}

```
- Вы также можете объявить метод для неструктурных типов.
- В этом примере мы видим числовой тип myFloat с методом Abs.
```
type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}
```
- Вы можете объявить метод только с получателем, тип которого определен в том же пакете, что и метод. Вы не можете объявить метод с получателем, тип которого определен в другом пакете (который включает встроенные типы, такие как int).
## Pointer receivers
- Вы можете объявлять методы с получателями указателей.
- Это означает, что тип получателя имеет литеральный синтаксис * T для некоторого типа T. (Кроме того, T сам по себе не может быть указателем, таким как int .)
- Методы с получателями указателей могут изменять значение, на которое указывает приемник. Поскольку методам часто требуется изменять свой приемник, приемники указателей встречаются чаще, чем приемники значений.
## Methods and pointer indirection
- Аналогичная вещь происходит в обратном направлении.
- Функции, которые принимают аргумент value, должны принимать значение этого определенного типа:
## Interfaces
- Тип интерфейса определяется как набор сигнатур методов.
- Значение типа интерфейса может содержать любое значение, реализующее эти методы.
## Interfaces are implemented implicitly (интерфейсы реализованы неявно)
- Тип реализует интерфейс, реализуя его методы. Нет явного объявления о намерениях, нет ключевого слова "implements".
- Неявные интерфейсы отделяют определение интерфейса от его реализации, которая затем может появиться в любом пакете без предварительной подготовки.
## Interface values
- По сути, значения интерфейса можно рассматривать как набор значений и конкретного типа: `(value, тип)`
- Значение интерфейса содержит значение определенного базового конкретного типа.
- Вызов метода для значения интерфейса выполняет метод с тем же именем для его базового типа.
```
func (t *T) M() {
	fmt.Println(t.S)
}
```
## Interface values with nil underlying values
- Если конкретное значение внутри самого интерфейса равно нулю, метод будет вызван с нулевым получателем.
- В некоторых языках это вызвало бы исключение нулевого указателя, но в Go принято писать методы, которые изящно обрабатывают вызов с нулевым получателем (как в случае с методом M в этом примере).
- Обратите внимание, что значение интерфейса, которое содержит нулевое конкретное значение, само по себе не равно нулю.
```
func (t *T) M() {
	if t == nil {
		fmt.Println("<nil>")
		return
	}
	fmt.Println(t.S)
}
```
## Nil interface values
- Значение интерфейса nil не содержит ни значения, ни конкретного типа.
- Вызов метода в интерфейсе nil является ошибкой выполнения, поскольку внутри кортежа интерфейса нет типа, указывающего, какой конкретный метод вызывать.
```
package main

import "fmt"

type I interface {
	M()
}

func main() {
	var i I
	describe(i)
	i.M()
}

func describe(i I) {
	fmt.Printf("(%v, %T)\n", i, i)
}

```
## The empty interface
- An empty interface may hold values of any type. (Every type implements at least zero methods.)
- The interface type that specifies zero methods is known as the _empty interface_: `interface{}`
```
func describe(i interface{}) {
	fmt.Printf("(%v, %T)\n", i, i)
}
```
## Type assertions (утверждения типа)
- Утверждение типа предоставляет доступ к конкретному значению, лежащему в основе значения интерфейса. `t := i.(T)`
- Этот оператор утверждает, что значение интерфейса i содержит конкретный тип T и присваивает базовое значение T переменной t .
- Если i не содержит значение T, оператор вызовет панику.
- Чтобы проверить, содержит ли значение интерфейса определенный тип, утверждение типа может возвращать два значения: базовое значение и логическое значение, сообщающее, выполнено ли утверждение успешно.
`t, ok := i.(T)`
- Если i имеет значение T, то t будет базовым значением, а ok будет true .
- Если нет, ok будет false, а t будет нулевым значением типа T, и паники не возникнет.
- Обратите внимание на сходство между этим синтаксисом и синтаксисом чтения с карты.
## Type switches (свитч по типам данных)
- Переключатель типа - это конструкция, которая допускает несколько утверждений типа последовательно.
- Переключатель типа похож на обычный оператор switch, но регистры в переключателе типа указывают типы (не значения), и эти значения сравниваются с типом значения, удерживаемого данным значением интерфейса.
```
switch v := i.(type) {
case T:
    // here v has type T
case S:
    // here v has type S
default:
    // no match; here v has the same type as i
}
```
- Объявление в переключателе типов имеет тот же синтаксис, что и утверждение типа i.(T), но конкретный тип T заменяется ключевым словом type.
- Этот оператор switch проверяет, содержит ли значение интерфейса i значение типа T или S. В каждом из случаев T и S переменная v будет иметь тип T или S соответственно и содержать значение, удерживаемое i. В случае по умолчанию (когда совпадения нет) переменная v имеет тот же тип интерфейса и значение, что и i.
## Stringers
- Одним из наиболее распространенных интерфейсов является Stringer, определяемый пакетом fmt.
```
type Stringer interface {
    String() string
}
```
- Stringer - это тип, который может описывать себя как строку. Пакет fmt (и многие другие) ищут этот интерфейс для печати значений.
## Errors
- Программы Go отображают состояние ошибки с помощью значений ошибок.
- Тип ошибки представляет собой встроенный интерфейс, аналогичный fmt.Stringer:
```
type error interface {
    Error() string
}
```
- (Как и в случае с fmt.Stringer, пакет fmt ищет интерфейс ошибки при печати значений.)
- Функции часто возвращают значение ошибки, и вызывающий код должен обрабатывать ошибки, проверяя, равна ли ошибка нулю.
```
i, err := strconv.Atoi("42")
if err != nil {
    fmt.Printf("couldn't convert number: %v\n", err)
    return
}
fmt.Println("Converted integer:", i)
```
- Нулевая ошибка означает успех; ненулевая ошибка означает неудачу.
## Readers
- Пакет ввода-вывода определяет интерфейс ввода-вывода.Reader, который представляет конец чтения потока данных.
- Стандартная библиотека Go содержит множество реализаций этого интерфейса, включая файлы, сетевые подключения, компрессоры, шифры и другие.
- Интерфейс ввода-вывода.Reader имеет метод чтения: `func (T) Read(b []byte) (n int, err error)`
- Read заполняет заданный фрагмент байта данными и возвращает количество заполненных байтов и значение ошибки. Она возвращает ввод-вывод.Ошибка EOF при завершении потока.
- Приведенный в примере код создает средство чтения strings.и использует его выходные данные по 8 байт за раз.
## Images
Package image defines the `Image` interface:
```
package image

type Image interface {
    ColorModel() color.Model
    Bounds() Rectangle
    At(x, y int) color.Color
}
```

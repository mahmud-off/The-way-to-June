## Goroutines
- Goroutine - это упрощенный поток, управляемый средой выполнения Go.
- Программы Goroutines работают в одном адресном пространстве, поэтому доступ к общей памяти должен быть синхронизирован. Пакет sync предоставляет полезные примитивы, хотя в Go они вам особо не понадобятся, поскольку есть и другие примитивы.
## Channels
- Каналы - это типизированный канал, по которому вы можете отправлять и получать значения с помощью оператора канала, <-
```
ch <- v    // Send v to channel ch.
v := <-ch  // Receive from ch, and
           // assign value to v.
```
The data flows in the direction of the arrow.
- Like maps and slices, channels must be created before use:
```
ch := make(chan int)
```
- По умолчанию отправка и получение блокируются до тех пор, пока другая сторона не будет готова. Это позволяет goroutines синхронизировать без явных блокировок или переменных условий.
Код примера суммирует числа в срезе, распределяя работу между двумя программами. Как только обе программы завершат свои вычисления, вычисляется конечный результат.
```
func sum(s []int, c chan int) {
	sum := 0
	for _, v := range s {
		sum += v
	}
	c <- sum // send sum to c
}

func main() {
	s := []int{7, 2, 8, -9, 4, 0}

	c := make(chan int)
	go sum(s[:len(s)/2], c)
	go sum(s[len(s)/2:], c)
	x, y := <-c, <-c // receive from c

	fmt.Println(x, y, x+y)
}

```
## Buffered Channels
- Каналы могут быть буферизованы. Укажите длину буфера в качестве второго аргумента для инициализации буферизованного канала:
```
ch := make(chan int, 100)
```
- Отправляет блок буферизованному каналу только тогда, когда буфер заполнен. Получает блок, когда буфер пуст.
```
func main() {
	ch := make(chan int, 2)
	ch <- 1
	ch <- 2
	fmt.Println(<-ch)
	fmt.Println(<-ch)
}
```
## Range and Close
- Отправитель может закрыть канал, чтобы указать, что больше значения отправляться не будут. Получатели могут проверить, был ли канал закрыт, присвоив выражению приема второй параметр: после
```
v, ok := <-ch
```
- `ok` is `false` if there are no more values to receive and the channel is closed.
- The loop `for i := range c` receives values from the channel repeatedly until it is closed.
-  Закрывать канал должен только отправитель, никогда получатель. Отправка по закрытому каналу вызовет панику.
- Channels aren't like files; you don't usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a `range` loop.
```
func fibonacci(n int, c chan int) {
	x, y := 0, 1
	for i := 0; i < n; i++ {
		c <- x
		x, y = y, x+y
	}
	close(c)
}

func main() {
	c := make(chan int, 10)
	go fibonacci(cap(c), c)
	for i := range c {
		fmt.Println(i)
	}
}
```
## Select
- Оператор select позволяет goroutine ожидать выполнения нескольких операций связи.
- Select блокируется до тех пор, пока не сможет выполняться одно из его обращений, затем оно выполняет это обращение. Оно выбирает одно случайным образом, если готовы несколько.
## Default Selection
- Вариант по умолчанию в select запускается, если ни один другой вариант не готов.
- Используйте вариант по умолчанию, чтобы попробовать отправить или получить без блокировки:
```
select {
case i := <-c:
    // use i
default:
    // receiving from c would block
}
```
## sync.Mutex
- Мы видели, как каналы отлично подходят для общения между программами. Но что, если нам не нужно общение? Что, если мы просто хотим убедиться, что только одна подпрограмма может обращаться к переменной одновременно, чтобы избежать конфликтов?
- Эта концепция называется взаимным исключением, а общепринятое название структуры данных, которая его обеспечивает, - мьютекс.
- Стандартная библиотека Go обеспечивает взаимное исключение с помощью sync.Mutex и двух его методов.
- Мы можем определить блок кода, который будет выполняться во взаимном исключении, окружив его вызовом Lock and Unlock, как показано в методе Inc .
- Мы также можем использовать defer, чтобы гарантировать, что мьютекс будет разблокирован, как в методе Value .
